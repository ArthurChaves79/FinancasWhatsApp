from flask import Flask, request, send_from_directory
from twilio.twiml.messaging_response import MessagingResponse
from datetime import datetime
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
import re
import uuid
from sklearn.linear_model import LinearRegression

app = Flask(__name__)
app.config['STATIC_FOLDER'] = os.path.join(os.getcwd(), 'static')

# Configura√ß√£o inicial
if not os.path.exists(app.config['STATIC_FOLDER']):
    os.makedirs(app.config['STATIC_FOLDER'])

plt.switch_backend('Agg')  # Configura√ß√£o para servidor

# Estrutura de dados
class FinancialData:
    def __init__(self):
        self.transactions = pd.DataFrame(columns=[
            'Data', 'Categoria', 'Descri√ß√£o', 'Valor', 'Tipo', 'Conta'
        ])
        self.accounts = []
        self.budgets = {}
        self.investment_profile = None

# IA Financeira
class FinancialAgent:
    def __init__(self):
        self.model = LinearRegression()
        self.categories = {
            'alimenta√ß√£o': ['mercado', 'restaurante', 'comida'],
            'transporte': ['uber', 'gasolina', 'estacionamento'],
            'entretenimento': ['cinema', 'streaming', 'jogos']
        }

    def analyze_spending(self, df):
        analysis = {}
        df['Data'] = pd.to_datetime(df['Data'])
        
        # An√°lise mensal
        monthly = df.groupby([df['Data'].dt.month, 'Tipo'])['Valor'].sum().unstack()
        analysis['monthly_trend'] = monthly.to_dict()
        
        # Principais categorias
        expenses = df[df['Tipo'] == 'Despesa']
        analysis['top_categories'] = expenses.groupby('Categoria')['Valor'].sum().nlargest(3).to_dict()
        
        return analysis

    def generate_chart(self, df, chart_type):
        filename = f"{uuid.uuid4()}.png"
        filepath = os.path.join(app.config['STATIC_FOLDER'], filename)
        
        try:
            if chart_type == 'expenses':
                expenses = df[df['Tipo'] == 'Despesa']
                data = expenses.groupby('Categoria')['Valor'].sum()
                plt.figure(figsize=(8, 8))
                data.plot.pie(autopct='%1.1f%%')
                plt.title('Distribui√ß√£o de Gastos')
            
            elif chart_type == 'monthly_trend':
                df['M√™s'] = pd.to_datetime(df['Data']).dt.month
                monthly_data = df.groupby(['M√™s', 'Tipo'])['Valor'].sum().unstack()
                monthly_data.plot(kind='bar')
                plt.title('Receitas vs Despesas por M√™s')
            
            plt.tight_layout()
            plt.savefig(filepath)
            plt.close()
            return filename
        except Exception as e:
            print(f"Erro ao gerar gr√°fico: {str(e)}")
            return None

# Inicializa√ß√£o
data_manager = FinancialData()
financial_ai = FinancialAgent()

# Rotas
@app.route('/static/<filename>')
def serve_static(filename):
    return send_from_directory(app.config['STATIC_FOLDER'], filename)

@app.route("/webhook", methods=["POST"])
def webhook():
    body = request.form.get("Body").strip().lower()
    response = MessagingResponse()
    
    try:
        # Comandos de gr√°ficos
        if 'gr√°fico' in body:
            chart_type = 'expenses' if 'gastos' in body else 'monthly_trend'
            filename = financial_ai.generate_chart(data_manager.transactions, chart_type)
            
            if filename:
                chart_url = f"{request.url_root}static/{filename}"
                msg = response.message("üìä Gr√°fico gerado:")
                msg.media(chart_url)
            else:
                response.message("‚ö†Ô∏è Dados insuficientes para gerar o gr√°fico")
        
        # Comandos anteriores (transa√ß√µes, contas, etc.)
        elif 'nova conta' in body:
            bank = body.split('nova conta no ')[-1].strip()
            if bank not in data_manager.accounts:
                data_manager.accounts.append(bank)
                response.message(f"üè¶ Conta {bank} cadastrada!")
            else:
                response.message(f"‚ö†Ô∏è Conta {bank} j√° existe")
        
        # ... (Outros comandos anteriores mantidos)
        
        else:
            response.message(process_message(body))
    
    except Exception as e:
        response.message(f"‚ö†Ô∏è Erro: {str(e)}")
    
    return str(response)

def process_message(message):
    # L√≥gica de processamento de mensagens
    if 'saldo' in message:
        return calculate_balance()
    
    elif 'relat√≥rio' in message:
        generate_report()
        return "üìä Relat√≥rio gerado em 'financas.xlsx'"
    
    # ... (Outras fun√ß√µes mantidas)
    
    return "ü§ñ Comando n√£o reconhecido. Tente 'Ajuda'"

def calculate_balance():
    receitas = data_manager.transactions[data_manager.transactions['Tipo'] == 'Receita']['Valor'].sum()
    despesas = data_manager.transactions[data_manager.transactions['Tipo'] == 'Despesa']['Valor'].sum()
    return f"üí∞ Saldo Total: R${receitas - despesas:.2f}"

def generate_report():
    data_manager.transactions.to_excel("financas.xlsx", index=False)

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 10000)))